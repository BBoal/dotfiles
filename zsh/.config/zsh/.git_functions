#!/bin/sh

gg() {
    echo "$(git rev-list --count HEAD) total commits" && git hm
}

gh() {
    GIT_STAGED_FILES=$(git diff --name-only --cached)
    if [ -z "$GIT_STAGED_FILES" ];then
        git add -u && git commit -m "$1"
    else
        git commit -m "$1"
    fi
}

gca(){
    GIT_STAGED_FILES=$(git diff --name-only --cached)
    if [ -z "$GIT_STAGED_FILES" ];then
        git commit -a --amend -C HEAD
    else
        git commit --amend -C HEAD
    fi
}

gitignore() {
    LANGUAGE=$(curl -L -s https://www.gitignore.io/api/list | tr "," "\n" | fzf)
    curl -L -s "https://www.gitignore.io/api/$LANGUAGE%2Cmacos" >.gitignore
}

ga() {
    if [ -z "$1" ];then
        1="$(pwd)"
    fi
    git add "$1"
}

gcl() {
    if [ -z "$1" ]; then
        GITURL=$(pbpaste)
    elif echo "$1" | grep '/' > /dev/null; then
        GITURL="https://github.com/$1.git"
    else
        GITURL="https://github.com/meain/$1.git"
    fi
    FOLDER="$(echo "$GITURL" | sed 's/.*\///g' | sed 's/\..*//g')"
    git clone "$GITURL"
    cd "$FOLDER" || return 1
}

git_sparse_clone() {
	rurl="$1"
	localdir="$(basename "$1")"
	shift 1

	mkdir -p "$localdir"
	cd "$localdir" || return 1

	git init
	git remote add -f origin "$rurl"
	git config core.sparseCheckout true

	# Loops over remaining args
	mkdir -p .git/info
	touch .git/info/sparse-checkout
	for i; do
		echo "$i" >> .git/info/sparse-checkout
	done

	git pull origin master
}

git_untracked_to_gitignore() {
    git status | grep -P \"^\\t\" | grep -vF .gitignore | sed \"s/^\\t//\" >>.gitignore
}

git_list_ignord_files() {
    git ls-files --others -i --exclude-standard
}

git_list_unmerged_branches() {
    git checkout master && git branch -a --no-merged
}

git_delete_tag() {
    git tag --delete "$1" && git push --delete origin "$1"
}

git_edit_conflicting_files() {
    git diff --name-only --diff-filter=U | xargs "$EDIOR"
}

git_checkout_pr(){
    git pr checkout "$(git pr list | sed 's/^\ *//' | fzf | sed 's/.\([0-9]*\).*/\1/')"
}

git_usebranch() {
    [ -z "$1" ] && echo 'Provide branchname.' && return 1
    git branch "$1"
    git reset --keep HEAD~
    git checkout "$1"
}
